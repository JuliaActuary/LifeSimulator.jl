var documenterSearchIndex = {"docs":
[{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"EditURL = \"getting_started.jl\"","category":"page"},{"location":"tutorial/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Let's run a few simulations to get a feel of the package functionality.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"First, we have to choose a Model to simulate. There are a few to choose from, essentially divided in two categories: TermLifeModels, representing term life insurance, and UniversalLifeModels, representing universal life insurance. For this example, we will take a simple term life model based on lifelib, reimplemented in Julia. There are two implementations we can choose from: a memoized implementation, and an iterative implementation. The memoized implementation replicates 1:1 the design of the corresponding Python library, and has a less polished interface. For this reason, we will take the iterative implementation, LifelibBasiclife, which will allow us to showcase most of the data structures relevant in context of this package.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"display(x) = println(sprint(show, MIME\"text/plain\"(), x; context = :color => true)) # hide\n\nusing LifeSimulator, Dates\nmodel = LifelibBasiclife()","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Second, we define a bunch of policies that we want to simulate forward in time. Such policies represent life insurance products. Ideally, we would simulate individual products, that is, separate contracts for different customers. However, for efficiency and scalability reasons, such insurance products are implemented as sets of products. That is, a contract is weighted by a number of customers holding this type of contract. those are called PolicySets. We can generate some randomly using Base.rand:","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"rand(PolicySet, 500)","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"But for this example, we'll use a small set of fixed policies to guarantee the consistency of results across runs (which will allow us to reliably interpret what we obtain). We'll stick to the default values for the most part.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"policies = [\n  PolicySet(Policy(term = Year(20), age = Year(20), premium = 200_000), 100),\n  PolicySet(Policy(term = Year(20), age = Year(45), premium = 600_000), 80),\n  PolicySet(Policy(term = Year(10), age = Year(70), premium = 400_000), 50),\n]","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Now that we have a model and policies to evolve over time, we can carry out a simulation using simulate over a specified time range.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"First, as we're just experimenting, we can simulate a single step (which is equivalent to a single month) and print what happened during that time. The data structure that will be provided to our custom callback function will be a SimulationEvents, and we can just print it out for now.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"n = 1 # number of timesteps\nsimulate(model, policies, n) do events\n  display(events)\nend;\nnothing #hide","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"This SimulationEvents data structure has information about deaths, lapses, new and expired policies, claims and expenses. This is all useful to compute cash flows and miscellaneous costs involved for the insurance company providing the insurance products.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"In fact, the computation of cash flows is usually the main point of interest of such simulations, which warranted its implementation in this package: enters CashFlow.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Now, instead of printing the raw SimulationEvents, we can print the associated CashFlow quite simply:","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"simulate(model, policies, n) do events\n  cf = CashFlow(events, model)\n  display(cf)\nend;\nnothing #hide","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"We got a negative cashflow, from the perspective of the insurance company. Why is that? In our model, establishing new contracts (policies) has a fixed cost, which is part of the expenses reported by the SimulationEvents during printing earlier.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"But note that we only computed cash flows due to the various events that occurred during the simulation. We have not computed cash flows related to active policies, and therefore, our value for the net cash flow is incomplete! Let's fix that. We will need to manually build a Simulation object so we can reference during the computation of cash flows, and use simulate! to mutate this simulation in-place. Note that the simulate function essentially does the same thing, it's just that it won't give you access to the simulation object itself.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"simulation = Simulation(model, policies)\nsimulate!(simulation, n) do events\n  cf = CashFlow(simulation) # premiums, policy upkeep costs, commissions\n  cf += CashFlow(events, model) # claims, costs for new policies\n  display(cf)\nend;\nnothing #hide","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Note how the net cashflow is now positive: the premiums balance out the costs incurred by policy acquisitions to the insurance company, as well as claims made during that period. It even turns out that commissions on said premiums now actually make most of the cash flow; indeed, by default there is a 60% commission rate for the first year.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"Instead of building a Simulation, and then computing cash flows manually, convenience functions are provided when the sole interest of the simulation is to compute cash flows. Let's for example simulate 5 months now and see what we get:","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"n = 5\nCashFlow(model, policies, n)","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"CashFlow(model, policies, n) do cashflow\n  display(cashflow)\nend;\nnothing #hide","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"For term life insurance products, it will be normal for the company to have a decreasing revenue over time, as the premium remains fixed while mortality increases. An exception is typically made for the first year, during which commissions to agents are generally paid a large percentage of the premium.","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorial/getting_started/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"EditURL = \"customizing_models.jl\"","category":"page"},{"location":"tutorial/customizing_models/#Customizing-models","page":"Customizing models","title":"Customizing models","text":"","category":"section"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"LifeSimulator.jl is designed to allow users to provide their own models. Notably, custom models for mortality and lapses may be specified, to allow for a more realistic parametrization than the default values. On the longer term, it might be possible to bundle common interfaces for whole Models, but we haven't explored enough insurance products to be able to design a cohesive interface between different types of products. Curently, we have a very basic categorization of insurance product models into term life and universal life models (via the types TermLifeModel and UniversalLifeModel). These don't represent all the types of insurance models, and have a single implementation with limited functionality at the moment, LifelibBasiclife and LifelibSavings (greatly inspired by lifelib, as their name suggests).","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"Nonetheless, these insurance models allow us to carry out simulations and produce reasonable data, and even more so with custom mortality and lapse models.","category":"page"},{"location":"tutorial/customizing_models/#Mortality-model","page":"Customizing models","title":"Mortality model","text":"","category":"section"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"Mortality models are defined as subtypes of MortalityModel. Documentation for this abstract type reveals that we need to extend monthly_mortality_rate or annual_mortality_rate, whichever we prefer.","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"Let's create our own mortality model which believes that female individuals are immortal and that men very frequently die. After creating a basic struct, we extend annual_mortality_rate with the corresponding logic:","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"using LifeSimulator, Dates\n\nBase.@kwdef struct SexDiscriminatingMortality <: MortalityModel\n  annual_rate::Float64 = 0.4\nend\n\nfunction LifeSimulator.annual_mortality_rate(model::SexDiscriminatingMortality, ::Month, policy::Policy)\n  if policy.sex == FEMALE\n    0.0\n  else\n    model.annual_rate\n  end\nend","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"We can now try to simulate using this model and see how that affects the population after 5 years:","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"mortality = SexDiscriminatingMortality()\nlapse = ConstantLapse(0.0) # this ensures all policy decrements are due to deaths\nmodel = LifelibBasiclife(; mortality, lapse)\npolicies = [\n  PolicySet(Policy(sex = MALE), 100),\n  PolicySet(Policy(sex = FEMALE), 100),\n]\nsim = simulate(model, policies, 60)\n\nmale, female = sim.active_policies\n(male.count, female.count)","category":"page"},{"location":"tutorial/customizing_models/#Lapse-model","page":"Customizing models","title":"Lapse model","text":"","category":"section"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"Similarly to mortality models, lapse models are defined as subtypes of a LapseModel abstract type. We also need to implement a method to compute an annual or monthly lapse rate, but this time the default is not to associate lapse rates to individual policies for performance reasons. Instead, if we wish to do so, we will have to specify rates_are_per_policy(model::MyModel) = true. Let's define a model that thinks only females lapse their contracts, and with a very high default probability:","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"Base.@kwdef struct SexDiscriminatingLapse <: LapseModel\n  annual_rate::Float64 = 0.7\nend\n\nfunction LifeSimulator.annual_lapse_rate(model::SexDiscriminatingLapse, ::Month, policy::Policy)\n  if policy.sex == MALE\n    0.0\n  else\n    model.annual_rate\n  end\nend\n\nLifeSimulator.rates_are_per_policy(::SexDiscriminatingLapse) = true","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"Let's see this in action:","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"mortality = ConstantMortality(0.0) # this ensures all policy decrements are due to lapses\nlapse = SexDiscriminatingLapse()\nmodel = LifelibBasiclife(; mortality, lapse)\npolicies = [\n  PolicySet(Policy(sex = MALE), 100),\n  PolicySet(Policy(sex = FEMALE), 100),\n]\nsim = simulate(model, policies, 60)\n\nmale, female = sim.active_policies\n(male.count, female.count)","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"Of course, we can customize both mortality and lapse models at the same time:","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"mortality = SexDiscriminatingMortality()\nlapse = SexDiscriminatingLapse()\nmodel = LifelibBasiclife(; mortality, lapse)\npolicies = [\n  PolicySet(Policy(sex = MALE), 100),\n  PolicySet(Policy(sex = FEMALE), 100),\n]\nsim = simulate(model, policies, 60)\n\nmale, female = sim.active_policies\n(male.count, female.count)","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"And this also works with the LifelibSavings model:","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"model = LifelibSavings(; mortality, lapse)\nsim = simulate(model, policies, 60)\n\nmale, female = sim.active_policies\n(male.count, female.count)","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"","category":"page"},{"location":"tutorial/customizing_models/","page":"Customizing models","title":"Customizing models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#API","page":"Reference","title":"API","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [LifeSimulator]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [LifeSimulator]\nPrivate = false","category":"page"},{"location":"reference/#LifeSimulator.SHOW_PROGRESS","page":"Reference","title":"LifeSimulator.SHOW_PROGRESS","text":"Boolean flag indicating whether to show progress during a simulation.\n\nSee also: simulate, simulate!\n\n\n\n\n\n","category":"constant"},{"location":"reference/#LifeSimulator.CashFlow","page":"Reference","title":"LifeSimulator.CashFlow","text":"Represents cashflows, typically to be computed during a Simulation over an insurance Model.\n\nThe present value of future cashflows is estimated from the future cashflows using a model-provided discount rate.\n\nCashflows may be added with +, which will perform the addition over each respective field.\n\nSee also: Simulation, Model\n\nstruct CashFlow\n\npremiums::Float64\ninvestments::Float64\nclaims::Float64\nexpenses::Float64\ncommissions::Float64\naccount_value_changes::Float64\nnet::Float64\ndiscounted::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.LapseModel","page":"Reference","title":"LifeSimulator.LapseModel","text":"Model expressing lapses, e.g. due to payment defaults.\n\nA given subtype L is expected to define either of:\n\nmonthly_lapse_rate(model::L, time::Month)\nmonthly_lapse_rate(model::L, time::Month, policy::Policy)\nannual_lapse_rate(model::L, time::Month)\nannual_lapse_rate(model::L, time::Month, policy::Policy)\n\nWhether to define a 2- or 3-argument method depends on whether the lapse rate as computed by the model is policy-specific. In such a case, in addition of defining 3-argument methods, you must implement rates_are_per_policy(::LapseModel) = true; the default is for it to be false implying that 2-argument methods are required.\n\nabstract type LapseModel\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.LifelibBasiclife","page":"Reference","title":"LifeSimulator.LifelibBasiclife","text":"Term life insurance model replicating the functionality of lifelib's basiclife module.\n\nstruct LifelibBasiclife{M<:MortalityModel, L<:LapseModel} <: TermLifeModel\n\nmortality::MortalityModel\nlapse::LapseModel\nload_premium_rate::Float64\nacquisition_cost::Float64: One-time cost for new policies.\nannual_maintenance_cost::Float64: Annual maintenance cost per policy.\ncommission_rate::Float64: Agents selling insurance products get paid a commission, whose value is a percentage of the premium paid during the first year.\ninflation_rate::Float64: Roughly estimated average for the inflation rate.\ndiscounts::Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.LifelibSavings","page":"Reference","title":"LifeSimulator.LifelibSavings","text":"Universal life model reimplemented from lifelib's savings library.\n\nstruct LifelibSavings{M<:MortalityModel, L<:LapseModel} <: UniversalLifeModel\n\nmortality::MortalityModel\nlapse::LapseModel\nmaintenance_fee_rate::Float64\ncommission_rate::Float64\ninsurance_risk_cost::Float64\ninvestment_rates::Vector{Float64}\nacquisition_cost::Float64: One-time cost for new policies.\ninflation_rate::Float64: Roughly estimated average for the annual inflation rate.\nannual_maintenance_cost::Float64: Annual maintenance cost per policy.\nannual_discount_rate::Float64: Estimated average for the future devaluation of cash.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.Model","page":"Reference","title":"LifeSimulator.Model","text":"Model defining the evolution of policies with regards to lapses, cashflows and, for UniversalLifeModels, account values for policy holders.\n\nModels are to be evaluated using a Simulation.\n\nSee also: Policy, TermLifeModel, UniversalLifeModel\n\nabstract type Model\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.MortalityModel","page":"Reference","title":"LifeSimulator.MortalityModel","text":"Mortality model.\n\nA given subtype M is expected to define either of:\n\nmonthly_mortality_rate(model::M, time::Month, policy::Policy)\nmonthly_mortality_rate(model::M, time::Month, age::Year)\nannual_mortality_rate(model::M, time::Month, policy::Policy)\nannual_mortality_rate(model::M, time::Month, age::Year)\n\nwhere, by default, the form with Policy as third argument simply defaults to computing the age at the current time and call a method with age::Year as third argument, defined for convenience.\n\nabstract type MortalityModel\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.Policy","page":"Reference","title":"LifeSimulator.Policy","text":"Policy held with a corresponding account value.\n\nstruct Policy\n\nsex::Sex\nage::Dates.Year\nwhole_life::Bool: Whether the policy should last as long as its beneficiary.\nassured::Float64: Sum assured by the policy.\npremium::Float64: Premium for the policy.\nissued_at::Dates.Month: Month (after the start of the simulation) the contract has been issued.\nterm::Dates.Year\nproduct::LifeSimulator.Product\naccount_value::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.PolicySet","page":"Reference","title":"LifeSimulator.PolicySet","text":"Aggregation of a specific type of policy among many policy holders.\n\nThe account for universal life models is therefore also unique among all policy holders, amounting to a total of set.policy.account_value * policy_count(set)\n\nstruct PolicySet\n\npolicy::Policy\ncount::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.Simulation","page":"Reference","title":"LifeSimulator.Simulation","text":"Simulation parametrized by a particular Model.\n\nThe simulation time starts at the current date by default. The simulation is carried out every month, producing events ([SimulationEvents]) corresponding to what happened between two timesteps, i.e. from one month to the other. The simulation is nonetheless stateful, meaning that such events may only be produced once; the next evaluation will return the events for the timestep after that.\n\nSee also: next!\n\nmutable struct Simulation{M<:Model}\n\nmodel::Model\nactive_policies::Vector{PolicySet}\ninactive_policies::Vector{PolicySet}\ntime::Dates.Month: Current simulation time, incremented after every simulation step.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.SimulationEvents","page":"Reference","title":"LifeSimulator.SimulationEvents","text":"Events that happen as part of a simulation timestep for a Model.\n\nThese events are meant to be processed by the user in order to generate quantities of interest that do not involve simulation-related state. This is, for example, how the CashFlow quantities are computed.\n\nmutable struct SimulationEvents\n\ntime::Dates.Month: Month during which the events started to be simulated. Events occur between time and time + Month(1) - Day(1).\nlapses::Vector{Pair{PolicySet, Float64}}\ndeaths::Vector{Pair{PolicySet, Float64}}\nexpirations::Vector{PolicySet}\nclaimed::Float64: Amount resulting from expired or lapsed policies or for which the holder has died.\nstarts::Vector{PolicySet}\nexpenses::Float64: Policies which started at the beginning of the month.\naccount_changes::Vector{Pair{PolicySet, LifeSimulator.AccountChanges}}\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.TermLifeModel","page":"Reference","title":"LifeSimulator.TermLifeModel","text":"Term life model.\n\nTerm life contracts start at a given date, and expire at a specified term. Upon death, the policy may be claimed, providing the policy holder with an assured amount.\n\nPremiums must be paid every month, otherwise the contract is cancelled (lapses).\n\nabstract type TermLifeModel <: Model\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.UniversalLifeModel","page":"Reference","title":"LifeSimulator.UniversalLifeModel","text":"Universal life model.\n\nThe defining property of a universal life model is that the contract between an insurance company and a policy holder involves a client-managed bank account, where the policy holder is responsible for keeping the bank account appropriately filled.\n\nLapses do not occur in absence of a payment, but rather when the bank account runs out of money while fees or premiums must be paid. It is, for example, for the policy holder to put a lot of money in the bank account and forget about it for a while, as opposed to a regular term life insurance model which requires frequent payments without such buffer.\n\nabstract type UniversalLifeModel <: Model\n\n\n\n\n\n","category":"type"},{"location":"reference/#LifeSimulator.annual_lapse_rate","page":"Reference","title":"LifeSimulator.annual_lapse_rate","text":"annuallapserate(model::LapseModel, time::Month)     annuallapserate(model::LapseModel, time::Month, policy::Policy)\n\nCompute an annual lapse rate for the given model.\n\nnote: Note\nSimulations with simulate will use monthly_lapse_rate. If your model more naturally outputs monthly lapse rates, we recommend you to extend monthly_lapse_rate instead.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LifeSimulator.annual_mortality_rate","page":"Reference","title":"LifeSimulator.annual_mortality_rate","text":"annual_mortality_rate(model::MortalityModel, time::Month, policy::Policy)\nannual_mortality_rate(model::MortalityModel, time::Month, age::Year)\n\nCompute an annual mortality rate for the given model.\n\nnote: Note\nSimulations with simulate will use monthly_mortality_rate. If your model more naturally outputs monthly mortality rates, we recommend you to extend monthly_mortality_rate instead.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LifeSimulator.annual_mortality_rate-Tuple{MortalityModel, Dates.Month, Policy}","page":"Reference","title":"LifeSimulator.annual_mortality_rate","text":"Default to a mortality rate depedent on age and time only.\n\nannual_mortality_rate(\n    model::MortalityModel,\n    time::Dates.Month,\n    policy::Policy\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#LifeSimulator.estimate_premiums-Tuple{LifelibBasiclife, Any, Any}","page":"Reference","title":"LifeSimulator.estimate_premiums","text":"Run a first simulation to estimate premiums for each policy, returning policies with the estimated premiums.\n\nInstead of running a full simulation, and producing a SimulationEvents at every step, we manually go through the lapse and mortality stages only to speed it up a bit.\n\nestimate_premiums(\n    model::LifelibBasiclife,\n    policies,\n    n\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#LifeSimulator.monthly_lapse_rate","page":"Reference","title":"LifeSimulator.monthly_lapse_rate","text":"monthlylapserate(model::LapseModel, time::Month)     monthlylapserate(model::LapseModel, time::Month, policy::Policy)\n\nCompute the monthly lapse rate for the given model. Falls back to a renormalization of [annual_lapse_rate] over 1/12 year.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LifeSimulator.monthly_mortality_rate","page":"Reference","title":"LifeSimulator.monthly_mortality_rate","text":"monthly_mortality_rate(model::MortalityModel, time::Month, policy::Policy)\nmonthly_mortality_rate(model::MortalityModel, time::Month, age::Year)\n\nCompute the monthly mortality rate for the given model. Falls back to a renormalization of annual_mortality_rate over 1/12 year.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LifeSimulator.next!-Tuple{Simulation{<:LifelibBasiclife}, SimulationEvents}","page":"Reference","title":"LifeSimulator.next!","text":"Perform a simulation timestep over the LifelibBasiclife model, returning a SimulationEvents.\n\nFirst, the policies which reached their term are removed, yielding claims and account changes.\n\nSecond, the policies which start from the current month are added, yielding expenses (costs for the insurance company).\n\nThen, at the middle of the month, deaths and lapses occur. Finally, the simulation time is incremented.\n\nA callback may be run just before the deaths and lapses occur, as the original basiclife model considers lapses and deaths to be part of the next iteration (i.e., deaths and lapses occur prior to the next step, and not in the current step).\n\nnext!(\n    sim::Simulation{<:LifelibBasiclife},\n    events::SimulationEvents;\n    callback\n) -> SimulationEvents\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#LifeSimulator.next!-Tuple{Simulation{<:LifelibSavings}, SimulationEvents}","page":"Reference","title":"LifeSimulator.next!","text":"Perform a simulation timestep over the LifelibSavings model, returning a SimulationEvents.\n\nFirst, the policies which reached their term are removed, yielding claims and account changes.\n\nSecond, the policies which start from the current month are added, yielding expenses (costs for the insurance company).\n\nThird, all account values are updated, with:\n\nA premium amount put into the bank account (minus fees, the load premium rate).\nMaintenance fees withdrawn from the back account.\nInsurance costs withdrawn from the back account.\nInvestments realized during the previous month.\n\nThen, at the middle of the month, deaths and lapses occur. Finally, the simulation time is incremented.\n\nnext!(\n    sim::Simulation{<:LifelibSavings},\n    events::SimulationEvents\n) -> SimulationEvents\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#LifeSimulator.policies_from_csv","page":"Reference","title":"LifeSimulator.policies_from_csv","text":"Import policies from CSV files compatible with the lifelib model.\n\npolicies_from_csv() -> Vector{PolicySet}\npolicies_from_csv(file::AbstractString) -> Vector{PolicySet}\n\n\n\n\n\n\n","category":"function"},{"location":"reference/#LifeSimulator.simulate!-Tuple{Any, Simulation, Int64}","page":"Reference","title":"LifeSimulator.simulate!","text":"simulate!(f, sim::Simulation, n)\n\nIteratively update a Simulation in-place with n 1-month timesteps.\n\nSee also: simulate\n\nsimulate!(f, sim::Simulation, n::Int64) -> Simulation\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#LifeSimulator.simulate-Tuple{Any, Model, Any, Int64}","page":"Reference","title":"LifeSimulator.simulate","text":"simulate(f, model, policies, n)\n\nSimulate a set of policies forward in time according to the provided model, for n months.\n\nAfter every iteration, f(events::SimulationEvents) is called, and may be used for example to compute and keep track of cashflows.\n\nSee also: SimulationEvents, CashFlow\n\nsimulate(f, model::Model, policies, n::Int64) -> Simulation\n\n\n\n\n\n\n","category":"method"},{"location":"#LifeSimultor.jl","page":"Home","title":"LifeSimultor.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LifeSimulator is a package for simulating insurance products forward in time. It currently contains two classes of models: TermLifeModel and UniversalLifeModel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The novelty of this package lies in the implementation strategy for such simulations. In the actuarial world, data-oriented designs using spreadsheet-like functionality are widely used. Such designs rely on extensive caching for their performance; however, as data dependencies may be complex for more elaborate models, managing the cache size is not trivial and may hurt performance or increase memory consumption if not carefully managed. We chose here to implement a simulation mechanism using a straightforward iterative approach, where policies are evolved forward in time. We believe it allows for simpler implementations, better reusability of functions across models, and ease of extensibility; for the latter, we support arbitrary user-defined callbacks, along with access to explicit simulation events SimulationEvents at every timestep.","category":"page"}]
}
